void Pushstack(stack &S, ElemType x, int &top)//进栈
{
    if(top == m)
        error("overflow");//上溢
    else
    {
        top = top + 1;
        S[top] = x;
    }
}

void PopStack(Stack &S, int  &top)//退栈
{
    if (top = 0)
        error("underflow");//下溢
    else
        top = top - 1;
}

bool EmptyStack(Stack &S, int &top)//判栈空
{
    if (top = 0)
        return true;
    else
        return false;
}

ElemType TopStack(Stack &S, int &top)//读取栈顶元素
{
    return S[top];
}

//在第i个栈上插入一个元素
void pushsi(int i, ElemType x, int T[], int B[])
{
    if (T[i] = B[i + 1])
        overflow(i);//转第i个栈溢出处理
    else 
    {
        T[i] = T[i] + 1;
        L[T[i]] = x;
    }
}





void overflow(int i)
//在第i个栈上做插入时发生栈满溢的处理过程
{
    k = i + 1;
    while ((k <= n) && (T[k] == B[k + 1]))
        k = k + 1;
    if (k > n)
        goto S;//此时右边无空闲位置，转去左边找
    else 
    {/*找到第k个栈有空闲单元(i < k <= n),将从第k个栈的栈顶元素起到第i + 1 个栈的栈底元素为止，
        依次向右移动一个位置*/
        for (j = T[k]; j >= B[i + 1] + 1; j--)
            L[j + 1] = L[j];
        for (p = i + 1; p <= k; p++)
            B[p] = B[p] + 1;//修改移动后的栈底指针
        for (p = i; p < k; p++)
            T[p] = T[p] + 1;//修改移动后的栈顶指针
        L[T[i]] = x;
        return ;
    }
    S: k = i - 1;//准备从第i个栈左边起寻找空间位置
    while ((k >= 1) && (T[k] == B[k + 1]))
        k = k - 1;
    if (k < 1)
    {
        printf("All stack are full");
        return ;
    }
    else
    {/*找到第k个栈有空闲，(1 <= k <= i - 1),把从第k + 1 个栈的栈底元素起到第i个栈的
    栈顶止，各元素依次向左移动一个位置*/
        for (j = B[k + 1] + 1; j <= T[i]; j++)
            L[j - 1] = L[j];
        for (p = k + 1; p <= i; p++)
            B[p] = B[p - 1];
        for (p = k + 1; p <= i - 1; p++)
            T[p] = T[p] - 1;
        L[T[i]] = x;
        return ;
    }
}

void popsi(int i, ElemType &y, int T[], int B[])
//在第i个栈上进行删除
{
    if (T[i] == b[i])
        underflow(i);
    else
    {
        y = L[T[i]];
        T[i] = T[i] - 1;
    }
}


